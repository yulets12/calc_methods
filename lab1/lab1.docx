

Министерство науки и высшего образования Российской Федерации
Федеральное государственное бюджетное образовательное учреждение высшего образования
«Московский государственный технический университет имени Н.Э. Баумана (национальный исследовательский университет)»
(МГТУ им. Н.Э. Баумана)


ФАКУЛЬТЕТ                      «Информатика и системы управления»
КАФЕДРА        «Программное обеспечение ЭВМ и информационные технологии»



Отчет по лабораторной работе № 1
«Метод поразрядного поиска» 


По курсу «Методы вычислений»
Вариант 1



Студент: 	Белоусова Ю.С.
Группа: 		ИУ7-21М 
Преподаватель: 	Власов П.А.



Москва, 2022г.



1. Постановка задачи
Необходимо решить задачу одномерной минимизации:

методом поразрядного поиска.
Входные данные для варианта 1:
    • Целевая функция
    • Отрезок [a, b] = [0, 1]
	
2. Краткое описание метода поразрядного поиска
Метод поразрядного поиска – представляет собой модифицированный метод перебора. Реализованные в данном методе модификации исходят из следующих соображений: 
	1. Если оказывается, что , то отпадает необходимость вычислять  в точках ,  и т.д., так как  x*<= .
	2. Целесообразно сперва найти приближенное (грубо) значение x* , а затем уточнить это значение, используя более точный шаг.
Пусть ? - требуемая точность нахождения x*. При реализации, обычно, сперва фиксируют ? > ?, вычисляют  , до тех пор, пока не будет выполнено  условие При выполнении этого условия шаг уменьшается (как правило в четыре раза, а процесс поиска запускается в обратную сторону).
Алгоритм работы метода поразрядного поиска
1. ; 
2. 
3. если , то , иначе — к п.5
4. если то переход  к п. 2, иначе — к п.5
5. если  ? ? ?, то x* = ; f* = ; иначе — к п.6
6. переход к п.2.
3. Текст программы
function lab1()
    clc;
    show_points = 1;
    N = 0;
    a = 0;
    b = 1;
    eps = 1e-6;
    x0 = a;
    f0 = f(a);
    delta = a-b;
    iter = 0;
    xarr = [];
    yarr = [];
    while abs(delta) > eps
        delta = -delta/4;
        fprintf("Итерация %d: x0=%.10f, f0=%.10f, delta=%.10f\n", iter, x0, f0, delta);
        xarr = [xarr x0];
        yarr = [yarr f0];
        iter = iter + 1;
        x1 = x0 + delta;
        f1 = f(x1);
        while f0>f1 && a<=x1 && x1<=b
            x0 = x1;
            f0 = f1;
            xarr = [xarr x0];
            yarr = [yarr f0];
            x1 = x0 + delta;
            f1 = f(x1);
        end
        x0 = x1;
        f0 = f1;
    end
    fprintf("x*=%.10f, f*=%.10f\n",  x0, f0);
    fprintf("Количество вызовов f: %d\n", N);
    
    figure
    x = 0:1e-3:1;
    y = arrayfun(@(xi) f(xi), x);
    if show_points
        plot(x, y, x0, f0, '*', xarr, yarr, 'o');
    else
        plot(x, y, x0, f0, '*');
    end
    
    function y=f(x)
        y = exp((x^4 + x^2 - x + 5^(1/2))/5) + sinh((x^3 + 21*x +9)/(21*x + 6)) + 3.0;
        N = N +1;
    end
end



4. Результаты работы
№ п/п
?
N
x*
f(x*)
1
1e-2
21
0.5664062500
5.9895939936
2
1e-4
37
0.5713500977
5.9895596651
3
1e-6
49
0.5713148117
5.9895596634




